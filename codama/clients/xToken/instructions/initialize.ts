/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  combineCodec,
  getAddressDecoder,
  getAddressEncoder,
  getArrayDecoder,
  getArrayEncoder,
  getStructDecoder,
  getStructEncoder,
  getU16Decoder,
  getU16Encoder,
  getU64Decoder,
  getU64Encoder,
  getU8Decoder,
  getU8Encoder,
  transformEncoder,
  type AccountMeta,
  type AccountSignerMeta,
  type Address,
  type FixedSizeCodec,
  type FixedSizeDecoder,
  type FixedSizeEncoder,
  type Instruction,
  type InstructionWithAccounts,
  type InstructionWithData,
  type ReadonlyAccount,
  type ReadonlySignerAccount,
  type ReadonlyUint8Array,
  type TransactionSigner,
  type WritableAccount,
  type WritableSignerAccount,
} from '@solana/kit';
import { X_TOKEN_PROGRAM_ADDRESS } from '../programs';
import { getAccountMetaFactory, type ResolvedAccount } from '../shared';

export const INITIALIZE_DISCRIMINATOR = 0;

export function getInitializeDiscriminatorBytes() {
  return getU8Encoder().encode(INITIALIZE_DISCRIMINATOR);
}

export type InitializeInstruction<
  TProgram extends string = typeof X_TOKEN_PROGRAM_ADDRESS,
  TAccountAuthority extends string | AccountMeta<string> = string,
  TAccountBondingCurve extends string | AccountMeta<string> = string,
  TAccountMint extends string | AccountMeta<string> = string,
  TAccountTreasury extends string | AccountMeta<string> = string,
  TAccountAuthorityTokenAccount extends string | AccountMeta<string> = string,
  TAccountPayer extends string | AccountMeta<string> = string,
  TAccountSystemProgram extends
    | string
    | AccountMeta<string> = '11111111111111111111111111111111',
  TAccountTokenProgram extends
    | string
    | AccountMeta<string> = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',
  TAccountAssociatedTokenProgram extends
    | string
    | AccountMeta<string> = 'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL',
  TAccountRent extends string | AccountMeta<string> = string,
  TAccountFeeRecipientAccount extends string | AccountMeta<string> = string,
  TRemainingAccounts extends readonly AccountMeta<string>[] = [],
> = Instruction<TProgram> &
  InstructionWithData<ReadonlyUint8Array> &
  InstructionWithAccounts<
    [
      TAccountAuthority extends string
        ? ReadonlySignerAccount<TAccountAuthority> &
            AccountSignerMeta<TAccountAuthority>
        : TAccountAuthority,
      TAccountBondingCurve extends string
        ? WritableAccount<TAccountBondingCurve>
        : TAccountBondingCurve,
      TAccountMint extends string
        ? WritableAccount<TAccountMint>
        : TAccountMint,
      TAccountTreasury extends string
        ? WritableAccount<TAccountTreasury>
        : TAccountTreasury,
      TAccountAuthorityTokenAccount extends string
        ? WritableAccount<TAccountAuthorityTokenAccount>
        : TAccountAuthorityTokenAccount,
      TAccountPayer extends string
        ? WritableSignerAccount<TAccountPayer> &
            AccountSignerMeta<TAccountPayer>
        : TAccountPayer,
      TAccountSystemProgram extends string
        ? ReadonlyAccount<TAccountSystemProgram>
        : TAccountSystemProgram,
      TAccountTokenProgram extends string
        ? ReadonlyAccount<TAccountTokenProgram>
        : TAccountTokenProgram,
      TAccountAssociatedTokenProgram extends string
        ? ReadonlyAccount<TAccountAssociatedTokenProgram>
        : TAccountAssociatedTokenProgram,
      TAccountRent extends string
        ? ReadonlyAccount<TAccountRent>
        : TAccountRent,
      TAccountFeeRecipientAccount extends string
        ? WritableAccount<TAccountFeeRecipientAccount>
        : TAccountFeeRecipientAccount,
      ...TRemainingAccounts,
    ]
  >;

export type InitializeInstructionData = {
  discriminator: number;
  /** The number of decimals for the token. */
  decimals: number;
  /** Curve type (0 = linear, 1 = exponential, 2 = logarithmic) */
  curveType: number;
  /** Fees in basis points (100 = 1%) */
  feeBasisPoints: number;
  /** Owner username (max 32 bytes) - includes length in first byte */
  owner: Array<number>;
  /** Base price in lamports per token (scaled by 1e9) */
  basePrice: bigint;
  /** Slope parameter for pricing curve (scaled by 1e9) */
  slope: bigint;
  /** Maximum token supply */
  maxSupply: bigint;
  /** Fee recipient address */
  feeRecipient: Address;
  /** Initial pre-buy token amount in base units (optional, 0 to skip) */
  initialBuyAmount: bigint;
  /** Max SOL (lamports) willing to pay for initial pre-buy */
  initialMaxSol: bigint;
};

export type InitializeInstructionDataArgs = {
  /** The number of decimals for the token. */
  decimals: number;
  /** Curve type (0 = linear, 1 = exponential, 2 = logarithmic) */
  curveType: number;
  /** Fees in basis points (100 = 1%) */
  feeBasisPoints: number;
  /** Owner username (max 32 bytes) - includes length in first byte */
  owner: Array<number>;
  /** Base price in lamports per token (scaled by 1e9) */
  basePrice: number | bigint;
  /** Slope parameter for pricing curve (scaled by 1e9) */
  slope: number | bigint;
  /** Maximum token supply */
  maxSupply: number | bigint;
  /** Fee recipient address */
  feeRecipient: Address;
  /** Initial pre-buy token amount in base units (optional, 0 to skip) */
  initialBuyAmount: number | bigint;
  /** Max SOL (lamports) willing to pay for initial pre-buy */
  initialMaxSol: number | bigint;
};

export function getInitializeInstructionDataEncoder(): FixedSizeEncoder<InitializeInstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([
      ['discriminator', getU8Encoder()],
      ['decimals', getU8Encoder()],
      ['curveType', getU8Encoder()],
      ['feeBasisPoints', getU16Encoder()],
      ['owner', getArrayEncoder(getU8Encoder(), { size: 32 })],
      ['basePrice', getU64Encoder()],
      ['slope', getU64Encoder()],
      ['maxSupply', getU64Encoder()],
      ['feeRecipient', getAddressEncoder()],
      ['initialBuyAmount', getU64Encoder()],
      ['initialMaxSol', getU64Encoder()],
    ]),
    (value) => ({ ...value, discriminator: 0 }),
  );
}

export function getInitializeInstructionDataDecoder(): FixedSizeDecoder<InitializeInstructionData> {
  return getStructDecoder([
    ['discriminator', getU8Decoder()],
    ['decimals', getU8Decoder()],
    ['curveType', getU8Decoder()],
    ['feeBasisPoints', getU16Decoder()],
    ['owner', getArrayDecoder(getU8Decoder(), { size: 32 })],
    ['basePrice', getU64Decoder()],
    ['slope', getU64Decoder()],
    ['maxSupply', getU64Decoder()],
    ['feeRecipient', getAddressDecoder()],
    ['initialBuyAmount', getU64Decoder()],
    ['initialMaxSol', getU64Decoder()],
  ]);
}

export function getInitializeInstructionDataCodec(): FixedSizeCodec<
  InitializeInstructionDataArgs,
  InitializeInstructionData
> {
  return combineCodec(
    getInitializeInstructionDataEncoder(),
    getInitializeInstructionDataDecoder(),
  );
}

export type InitializeInput<
  TAccountAuthority extends string = string,
  TAccountBondingCurve extends string = string,
  TAccountMint extends string = string,
  TAccountTreasury extends string = string,
  TAccountAuthorityTokenAccount extends string = string,
  TAccountPayer extends string = string,
  TAccountSystemProgram extends string = string,
  TAccountTokenProgram extends string = string,
  TAccountAssociatedTokenProgram extends string = string,
  TAccountRent extends string = string,
  TAccountFeeRecipientAccount extends string = string,
> = {
  /** Authority that will control the bonding curve */
  authority: TransactionSigner<TAccountAuthority>;
  /** Bonding curve state account (PDA) - will be created by program */
  bondingCurve: Address<TAccountBondingCurve>;
  /** Token mint account - must be created by client before calling */
  mint: Address<TAccountMint>;
  /** Treasury account (holds SOL for bonding curve) */
  treasury: Address<TAccountTreasury>;
  /** Authority's token account (ATA) to receive initial pre-buy tokens */
  authorityTokenAccount: Address<TAccountAuthorityTokenAccount>;
  /** Payer for account creation and rent */
  payer: TransactionSigner<TAccountPayer>;
  /** System Program */
  systemProgram?: Address<TAccountSystemProgram>;
  /** Token Program */
  tokenProgram?: Address<TAccountTokenProgram>;
  /** Associated Token Program */
  associatedTokenProgram?: Address<TAccountAssociatedTokenProgram>;
  /** Rent sysvar */
  rent: Address<TAccountRent>;
  /** Fee recipient account (for initial pre-buy fee transfer) */
  feeRecipientAccount: Address<TAccountFeeRecipientAccount>;
  decimals: InitializeInstructionDataArgs['decimals'];
  curveType: InitializeInstructionDataArgs['curveType'];
  feeBasisPoints: InitializeInstructionDataArgs['feeBasisPoints'];
  owner: InitializeInstructionDataArgs['owner'];
  basePrice: InitializeInstructionDataArgs['basePrice'];
  slope: InitializeInstructionDataArgs['slope'];
  maxSupply: InitializeInstructionDataArgs['maxSupply'];
  feeRecipient: InitializeInstructionDataArgs['feeRecipient'];
  initialBuyAmount: InitializeInstructionDataArgs['initialBuyAmount'];
  initialMaxSol: InitializeInstructionDataArgs['initialMaxSol'];
};

export function getInitializeInstruction<
  TAccountAuthority extends string,
  TAccountBondingCurve extends string,
  TAccountMint extends string,
  TAccountTreasury extends string,
  TAccountAuthorityTokenAccount extends string,
  TAccountPayer extends string,
  TAccountSystemProgram extends string,
  TAccountTokenProgram extends string,
  TAccountAssociatedTokenProgram extends string,
  TAccountRent extends string,
  TAccountFeeRecipientAccount extends string,
  TProgramAddress extends Address = typeof X_TOKEN_PROGRAM_ADDRESS,
>(
  input: InitializeInput<
    TAccountAuthority,
    TAccountBondingCurve,
    TAccountMint,
    TAccountTreasury,
    TAccountAuthorityTokenAccount,
    TAccountPayer,
    TAccountSystemProgram,
    TAccountTokenProgram,
    TAccountAssociatedTokenProgram,
    TAccountRent,
    TAccountFeeRecipientAccount
  >,
  config?: { programAddress?: TProgramAddress },
): InitializeInstruction<
  TProgramAddress,
  TAccountAuthority,
  TAccountBondingCurve,
  TAccountMint,
  TAccountTreasury,
  TAccountAuthorityTokenAccount,
  TAccountPayer,
  TAccountSystemProgram,
  TAccountTokenProgram,
  TAccountAssociatedTokenProgram,
  TAccountRent,
  TAccountFeeRecipientAccount
> {
  // Program address.
  const programAddress = config?.programAddress ?? X_TOKEN_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    authority: { value: input.authority ?? null, isWritable: false },
    bondingCurve: { value: input.bondingCurve ?? null, isWritable: true },
    mint: { value: input.mint ?? null, isWritable: true },
    treasury: { value: input.treasury ?? null, isWritable: true },
    authorityTokenAccount: {
      value: input.authorityTokenAccount ?? null,
      isWritable: true,
    },
    payer: { value: input.payer ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    associatedTokenProgram: {
      value: input.associatedTokenProgram ?? null,
      isWritable: false,
    },
    rent: { value: input.rent ?? null, isWritable: false },
    feeRecipientAccount: {
      value: input.feeRecipientAccount ?? null,
      isWritable: true,
    },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolve default values.
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value =
      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;
  }
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value =
      'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address<'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'>;
  }
  if (!accounts.associatedTokenProgram.value) {
    accounts.associatedTokenProgram.value =
      'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL' as Address<'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL'>;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
  const instruction = {
    accounts: [
      getAccountMeta(accounts.authority),
      getAccountMeta(accounts.bondingCurve),
      getAccountMeta(accounts.mint),
      getAccountMeta(accounts.treasury),
      getAccountMeta(accounts.authorityTokenAccount),
      getAccountMeta(accounts.payer),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.associatedTokenProgram),
      getAccountMeta(accounts.rent),
      getAccountMeta(accounts.feeRecipientAccount),
    ],
    programAddress,
    data: getInitializeInstructionDataEncoder().encode(
      args as InitializeInstructionDataArgs,
    ),
  } as InitializeInstruction<
    TProgramAddress,
    TAccountAuthority,
    TAccountBondingCurve,
    TAccountMint,
    TAccountTreasury,
    TAccountAuthorityTokenAccount,
    TAccountPayer,
    TAccountSystemProgram,
    TAccountTokenProgram,
    TAccountAssociatedTokenProgram,
    TAccountRent,
    TAccountFeeRecipientAccount
  >;

  return instruction;
}

export type ParsedInitializeInstruction<
  TProgram extends string = typeof X_TOKEN_PROGRAM_ADDRESS,
  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> = {
  programAddress: Address<TProgram>;
  accounts: {
    /** Authority that will control the bonding curve */
    authority: TAccountMetas[0];
    /** Bonding curve state account (PDA) - will be created by program */
    bondingCurve: TAccountMetas[1];
    /** Token mint account - must be created by client before calling */
    mint: TAccountMetas[2];
    /** Treasury account (holds SOL for bonding curve) */
    treasury: TAccountMetas[3];
    /** Authority's token account (ATA) to receive initial pre-buy tokens */
    authorityTokenAccount: TAccountMetas[4];
    /** Payer for account creation and rent */
    payer: TAccountMetas[5];
    /** System Program */
    systemProgram: TAccountMetas[6];
    /** Token Program */
    tokenProgram: TAccountMetas[7];
    /** Associated Token Program */
    associatedTokenProgram: TAccountMetas[8];
    /** Rent sysvar */
    rent: TAccountMetas[9];
    /** Fee recipient account (for initial pre-buy fee transfer) */
    feeRecipientAccount: TAccountMetas[10];
  };
  data: InitializeInstructionData;
};

export function parseInitializeInstruction<
  TProgram extends string,
  TAccountMetas extends readonly AccountMeta[],
>(
  instruction: Instruction<TProgram> &
    InstructionWithAccounts<TAccountMetas> &
    InstructionWithData<ReadonlyUint8Array>,
): ParsedInitializeInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 11) {
    // TODO: Coded error.
    throw new Error('Not enough accounts');
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      authority: getNextAccount(),
      bondingCurve: getNextAccount(),
      mint: getNextAccount(),
      treasury: getNextAccount(),
      authorityTokenAccount: getNextAccount(),
      payer: getNextAccount(),
      systemProgram: getNextAccount(),
      tokenProgram: getNextAccount(),
      associatedTokenProgram: getNextAccount(),
      rent: getNextAccount(),
      feeRecipientAccount: getNextAccount(),
    },
    data: getInitializeInstructionDataDecoder().decode(instruction.data),
  };
}
